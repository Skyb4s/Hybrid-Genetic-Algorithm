# -*- coding: utf-8 -*-
"""ExamenInfo2doParcial

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Rupa25xSl_6MSOqpN4-_-XIBPw1SUAih

# UIDE
## Facultad de Ciencias Técnicas 
## Informática V
##Tema: Knapsack Problem
## Integrantes: 

*   Vanessa Iglesias
*   Sebastian Narvaez 
*   Sebastián Osorio
*   Martín Puente 
*   Alexis Rivera


## Fecha : 30/10/2021

# Descripción del problema a resolver

El problema tradicional de la mochila (Knapsack Problem) es un muy conocido problema de optimización; donde se prentende de obtener a partir de una lista de elementos predifinida encontrar la mejor combinación de items que acumulen el mayor valor. Además es necerario tener en cuenta las limitaciones fisicas de la maleta donde almacenaremos dichos elemetos, es necesario tomar en cuenta que cada uno tiene propiedades de peso y costo.
"""

#@markdown ## Inclusión de Librerías y Base de datos
import numpy as np
import pandas as pd

from google.colab import drive 
drive.mount('/content/gdrive')
dfDataBase = pd.read_csv('/content/gdrive/MyDrive/DataBase/KPDB.csv')

#@markdown ##Definición de funciones AG

def InitInd():
  return [np.random.randint(2,size=(N_Ind))]
  
def InitPop(N):
  population = np.zeros((N,N_Ind))
  for x in range(N):
    aux = InitInd()
    population[x][:] = aux[0][:]
  return population

def DecodeInd(Ind):
  Valores = np.zeros((N_Ind,3))
  aux_w = aux_v = aux_price = 0

  for i in range(len(Ind)):
    if (Ind[i]==1):
      Valores[i][:] = dfDataBase.iloc[i][:]
  dfValores = pd.DataFrame(Valores,columns=['Price','Volume','Weight'])

  aux_price = dfValores['Price'].sum()
  aux_v = dfValores['Volume'].sum()
  aux_w = dfValores['Weight'].sum()

  return aux_price, aux_v, aux_w
    
def DecodePop(Pop):

  decoded_pop = np.zeros((N_Ind,3))
  for i in range(len(Pop)):
    decoded_pop[i][:] = DecodeInd(Pop[i]) 

  return decoded_pop

def Fitness (Pop):

  new_pop_greedy = np.zeros((N_Ind))
  new_pop_ranking = np.zeros((N_Ind))
  dfInitialPop = pd.DataFrame(DecodePop(Pop),columns=['Price','Volume','Weight'])
  df_Fitness_Ranking = dfInitialPop.loc[(dfInitialPop['Volume']<= V) & (dfInitialPop['Weight']<= W )]  # & dfInitialPop['Weight'] <= W
  df_Fitness_Ranking = df_Fitness_Ranking.sort_values("Price", ascending=False)
  df_Fitness_Greedy = dfInitialPop.loc[(dfInitialPop['Volume'] > V) | (dfInitialPop['Weight'] > W )]
  df_Fitness_Greedy = df_Fitness_Greedy.sort_values("Price", ascending=False)
  #display(df_Fitness.head(30))
  selected_ind_Ranking = df_Fitness_Ranking.index.tolist() 
  df_Fitness_Greedy = df_Fitness_Greedy.index.tolist() 
  '''
  for i in selected_ind:
    new_pop[i] = 1
  '''

  return selected_ind_Ranking,df_Fitness_Greedy


def RandomCrossOver(parent_A,parent_B):
  
  position = np.random.randint(N_Ind)
  #print(position)
  child_A = np.append(parent_A[:position],parent_B[position:])
  position = np.random.randint(N_Ind)
  #print(position)
  child_B = np.append(parent_B[:position],parent_A[position:])

  return child_A,child_B

def UniformCrossOver(parent_A,parent_B):
  template = np.random.randint(2, size=N_Ind)
  child_A = np.zeros(N_Ind)
  child_B = np.zeros(N_Ind)
  for i in range(N_Ind):
    if (template[i] == 1):
      child_A[i] = parent_B[i]
      child_B[i] = parent_A[i]

    else:
      child_A[i] = parent_A[i] 
      child_B[i] = parent_B[i]
  return child_A,child_B

def NewPop(group_A,group_B,Pop):
  
  new_group = np.append(group_A,group_B)
  sorted_pop = np.zeros((N_Ind,N_Ind))
  new_pop =  np.zeros((N_Ind,N_Ind))
  for x in range(N_Ind):
    sorted_pop[x][:] = Pop[int(new_group[x])][:]

  
  if (len(group_A)%2 == 0 ):
    template = np.random.randint(2,size=len(group_A))
    for x in range(0,len(group_A),2):
      if (template[x]==1):
        new_pop[x][:],new_pop[x+1][:] = RandomCrossOver(sorted_pop[x],sorted_pop[x+1])
      else:
        new_pop[x][:],new_pop[x+1][:] = UniformCrossOver(sorted_pop[x],sorted_pop[x+1])
    for x in range(len(group_A)+1,len(new_group)):
      new_pop[x][:] = Mutation(sorted_pop[x])

  else:
    template = np.random.randint(2,size=len(group_A))
    for x in range(0,len(group_A)+1,2):
      if (template[x]==1):
        new_pop[x][:],new_pop[x+1][:] = RandomCrossOver(sorted_pop[x],sorted_pop[x+1])
      else:
        new_pop[x][:],new_pop[x+1][:] = UniformCrossOver(sorted_pop[x],sorted_pop[x+1])
    for x in range(len(group_A)+2,len(new_group)):
      new_pop[x][:] = Mutation(sorted_pop[x])

  return new_pop

def Mutation(Ind):
  
  position = np.random.randint(N_Ind,size=1)
  #print(position)
  if (Ind[position]==1):
    Ind[position]=0
  else:
    Ind[position]=1

  return Ind

def Restriction(Pop):
  a,b = Fitness(Pop)
  sort_hierarchy = np.append(a,b)
  new_pop = np.zeros((N_Ind,N_Ind),dtype=int)
  acc_ind = int(P_Selection*len(a))
  for x in range(len(a)):
    new_pop[x][:] = Pop[a[x]][:]
  for x in range(len(a)+1,len(a)+len(b)):
    aux = InitInd()
    new_pop[x][:] = aux[0][:]
  return new_pop

def Store_Best(Ind1,Ind2):

  dec_Ind1 = DecodeInd(Ind1)[0]
  dec_Ind2 = DecodeInd(Ind2)[0]
  if (dec_Ind1 > dec_Ind2):
    return Ind1
  else:
    return Ind2

def Show_Selected_Items(Ind):
  Valores = np.zeros((N_Ind,3))
  for i in range(len(Ind)):
    if (Ind[i]==1):
      Valores[i][:] = dfDataBase.iloc[i][:]
  dfValores = pd.DataFrame(Valores,columns=['Price','Volume','Weight'])
  dfValores = dfValores.loc[dfValores['Volume'] > 0]
  display(dfValores)

def AG():

  new_pop = InitPop(N_Ind)
  cont = 0
  cont2 = 0
  for x in range(N_Generations):
    Mate_Pop,Mutation_Pop = Fitness(new_pop)
    new_pop = NewPop(Mate_Pop,Mutation_Pop,new_pop)
    #AccPop,RejPop = Fitness(new_pop)
    new_pop = Restriction(new_pop)
    if (x==0):
      best = new_pop[0]
    
    best = Store_Best(best,new_pop[0])
    print('\n Gen: ', x , ' (Price, Volume, Weight) ', DecodeInd(new_pop[0]), '------> Best Ind overall : ', DecodeInd(best))
    if (DecodeInd(new_pop[0])[0]< DecodeInd(best)[0]):
      cont += 1
      if (cont==1):
        new_pop[1][:] = new_pop[0][:]
        new_pop[0][:] = best[:]
        cont = 0
    if (DecodeInd(new_pop[0]) == DecodeInd(best)):
      cont2 += 1
      if (cont2 == 3):
        new_pop = InitPop(N_Ind)
        cont2 = 0
       

  return best

   



'''
Principal features 
'''
N_Generations = 100
N_Ind = 250
P_Selection = 0.3
P_Mutation = 0.3
W = 545 #Maximum weight 
V = 169750 #Maximum volume cm3
init_population = InitPop(N_Ind)

"""### Solución:"""

Solution = AG()
Show_Selected_Items(Solution)